---
title: 30. 운영체제 기초 활용 2
date: 2024-05-27
categories: [ 정보처리기사 ]
tags: [ 정보처리기사 ]
layout: post
---

## 메모리 관리

### 기억장치 관리 전략

`관리 전략의 개요`

- 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 위치 등을 지정하여, 한정된 주기억장치의 공간을 효율적으로 사용

`반입 전략 | Fetch Strategy`

- 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략

>
>
>
> #### 요구 반입 | Demand Fetch
>
>
>
> - 실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
>
>
>
> #### 예상 반입 | anticipatory
>
>
>
> - 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법
>
>

`배치 전략 | Placement Strategy`

- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

>
>
>
> #### 최초 적합 | First Fit
>
>
>
> - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치
>
>
>
> #### 최적 적합 | Best Fit
>
>
>
> - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
>
>
>
> #### 최악 적합 | Worst Fit
>
>
>
> - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치
>
>

`교체 전략 | Replacement Strategy`

- 주기억장치의 모든 영역이 이미 사용 중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략

- 종류 : FIFO, OPT, LRU, NUR, SCR 등

### 주기억장치 할당 기법

`단일 분할 할당 기법`

- 주기억장치의 사용자 영역을 한 순간에 한 명의 사용자만이 사용하게 하는 기법

- 가장 단순한 기법으로 초기의 운영체제에서 많이 사용했던 기법

- 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 경계 레지스터(Boundary Register)가 사용

- 프로그램의 크기가 작을 경우 사용자 영역이 낭비될 수 있음

- 주기억장치보다 큰 프로그램을 실행하기 위해 오버레이 기법과 스와핑 기법을 사용

>
>
>
> #### Overlay | 중첩
>
>
>
> - 보조기억장치에 저장된 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재시켜 프로그램을 실행
> - 주기억장치의 공간이 부족하면 불필요한 조각이 위치한 장소에 새로운 프로그램 조각을 중첩하여 적재
> - 프로그램을 조각으로 분할하는 작업은 프로그래머가 수행하므로 시스템 구조나 프로그램 구조를 알아야 함
>
>

#### Swapping

- 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다가 필요에 따라 다른 프로그램과 교체하는 기법

- 가상기억장치의 페이징 기법으로 발전

`다중 분할 할당 기법`

>
>
>
> #### 고정 분할 할당 기법
>
>
>
> - 프로그램을 할당하기 전에 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고, 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
> - 프로그램을 실행하려면 프로그램 전체가 주기억장치에 위치해야 함
> - 프로그램이 분할된 영역보다 커서 들어갈 수 없는 경우가 발생할 수 있음
> - 내부 단편화 및 외부 단편화가 발생하여 주기억장치의 낭비가 많음
> - 실행할 프로그램의 크기를 미리 알고 있어야 함
>
>
>
> #### 가변 분할 할당 기법
>
>
>
> - 고정 분할 할당 기법의 단편화를 줄이기 위한 기법
> - 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
> - 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍의 정도를 높일 수 있음
> - 단편화를 상당 부분 해결하였으나, 영역과 영역 사이에 단편화가 발생
>
>

### 단편화

- 주기억장치에 프로그램을 할당하고 반납하는 과정에서 발생하는 사용되지 않는 작은 조각 공간

- 주기억장치 상에서 빈번하게 기억장소가 할당되고 반납됨에 따라 기억장소들이 조각들로 나누어지는 현상

`종류`

>
>
>
> #### 내부 단편화
>
>
>
> - 주기억장치 공간이 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남아있는 공간
>
>
>
> #### 외부 단편화
>
>
>
> - 주기억장치 공간보다 프로그램이 커서 할당되지 못한 남아있는 공간
>
>

`해결 방법`

>
>
>
> #### 통합 기법 | Coalescing
>
>
>
> - 인접해 있다면 두 개의 빈 분할 공간을 하나로 통합하여 효율성을 높이는 작업
>
>
>
> #### 압축 기법 | Compaction
>
>
>
> - 주기억장치 내 분산되어 있는 단편화 공간들을 통합하여 하나의 커다란 빈 공간을 만드는 작업
> - 가비지 컬렉션 작업이라고도 함
>
>
>
> #### 재배치 기법 | Relocation
>
>
>
> - 압축을 실행하여 이 과정에서 프로그램의 주소를 새롭게 지정해주는 기법
>
>

---

## 가상기억장치

### 개념

- 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것

- 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법

- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리

- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용

- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음

- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업이 필요

- 불록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있음

### 블록 분할 방법

`페이징 기법 | Paging`

- 가상기억장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법

- 외부 단편화는 발생하지 않으나 내부 단편화는 발생

- 가상 메모리를 일정한 크기로 나눈 단위를 페이지라고 하고, 물리 메모리를 일정한 크기로 나눈 블록을 프레임이라고 함

- 주소 변환을 위해서 페이지 맵 테이블이 필요

| 페이지 크기 | 기억장소 효율 | 단편화 | 입출력 시간 | 맵 테이블 |
|--------|---------|-----|--------|-------|
| 클수록    | 감소      | 증가  | 감소     | 감소    |
| 작을수록   | 증가      | 감소  | 증가     | 증가    |

`세그먼테이션 기법 | Segmentation`

- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하고 메모리를 할당하는 기법

- 세그먼트 테이블을 참조하여 해당 세그먼트의 시작주소와 더해져서 실제적인 물리적 위치로 변환

- 세그먼테이션 기법 사용 이유는 기억공간을 절약하기 위함

- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키가 필요

- 내부 단편화는 발생하지 않으나, 외부 단편화가 발생

- 주소 변환을 위해서 세그먼트 맵 테이블이 필요

>
>
>
> #### 주소 변환
>
>
>
> 1. 가상 주소의 변위값과 세그먼트의 크기 비교
> 2. 변위값이 작거나 같으면 기준번지와 변위값을 더해 주기억장치에 접근
> 3. 변위값이 크면 다른 영역을 침범하므로 실행 권한을 운영체제에 넘기고 트랩 발생
>
>

### 페이지 교체 알고리즘

`FIFO | First In First Out`

- 가장 먼저 메모리에 적재된 페이지를 먼저 교체하는 기법

- 프레임 개수를 늘리면 부재 발생이 감소해야하나, 오히려 더 늘어나는 Belady's Anomaly 이상현상 발생

`OPT | OPTimal replacement`

- 앞으로 가장 사용 안될 페이지를 교체

- 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이나 참조 상황을 예측하기 어려움

`LRU | Least Recently Used`

- 최근에 가장 오랫동안 사용되지 않는 페이지를 교체

`LFU | Least Frequently Used`

- 사용 빈도가 가장 적은 페이지를 교체

`NUR | Not Used Recently`

- 최근의 사용 여부를 확인하기 위해 각 페이지마다 두 개의 비트 사용

- 참조비트와 변형비트를 이용해서 페이지 교체

`SCR | Second Chance Replacement`

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법

### 가상기억장치 기타 관리 사항

`페이지 부재`

- 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상

- 페이지 부재가 일어나는 횟수를 페이지 부재 빈도라고 함

`구역성 | Locality`

- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질

- 스레싱을 방지하기 위한 워킹 셋 이론의 기반

>
>
>
> #### 시간 구역성 | Temporal Locality
>
>
>
> - 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상
> - 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음
> - Loop, Stack, Sub Routine 등
>
>
>
> #### 공간 구역성 | Spatial Locality
>
>
>
> - 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
> - 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음
> - 배열순회, 순차적 코드 실행 등
>
>

`워킹 셋 | Working Set`

- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로 페이지 부재 및 페이지 교체 현상을 줄여 프로세스의 기억장치 사용이 안정되게 함

- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변하기 때문에 워킹셋은 시간에 따라 변함

`스래싱 | Thrashing`

- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

- 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하됨

>
>
>
> #### 스래싱 현상 방지 방법
>
>
>
> - 다중 프로그래밍의 정도를 적정 수준으로 유지
> - 페이지 부재 빈도를 조절하여 사용
> - 워킹 셋을 유지
> - 부족한 자원을 증설하고, 일부 프로세스 중단시킴
> - CPU 성능에 대한 자료의 지속적인 관리 및 분석으로 임계치를 예상하여 운영
>
>

---

## 프로세스

### 개념

- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

- 실행 가능한 PCB가 있는 프로그램

- 운영체제가 관리하는 실행단위

- 프로세서가 할당되는 실체

- 활동 중인 프로시저

### 메모리상의 프로세스 영역

`코드 영역`

- 실행할 프로그램의 코드가 저장되는 영역

- 함수, 제어문, 상수 등이 지정

`데이터 영역`

- 전역변수와 정적 변수(static)변수가 할당되는 부분

- 프로그램이 종료되면 메모리에서 소멸

`스택 영역`

- 프로그램이 자동으로 사용하는 임시 메모리 영역

- 지역변수와 함수의 매개변수가 저장되는 영역으로 함수 호출이 완료되면 사라짐

`힙 영역`

- 프로그래머가 할당 / 해제하는 메모리 공간

- 동적 할당

### 프로세스 상태 전이

>
> 생성 | New  
> ↓  
> 준비 | Ready &nbsp; &nbsp; &nbsp; &nbsp; ← 대기 | Wait  
> ↓ Dispatch &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Wake Up  
> ↑ Timer Runout  
> 실행 | Run &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; → 대기 | Wait  
> ↓  
> 종료 | Exit
>

`프로세스 상태 전이 절차`

>
>
>
> #### 제출 | Submit
>
>
>
> - 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
>
>
>
> #### 접수 | Hold
>
>
>
> - 제출된 작업이 Spool 공간인 디스크의 할당 위치에 저장된 상태
>
>
>
> #### 준비 | Ready
>
>
>
> - 프로세스가 대기큐에서 프로세서를 할당받기 위해 기다리는 상태
> - 접수상태에서 준비상태로의 전이는 Job Scheduler에 의해 수행
>
>
>
> #### 실행 | Running
>
>
>
> - 프로세스가 프로세서를 할당받아 실행되는 상태
> - 프로세스 수행이 완료되기 전에 할당 시간이 종료되면 프로세스는 다시 준비 상태로 전이
> - 준비상태에서 실행상태로의 전이는 CPU Scheduler에 의해 수행됨(Dispatch)
>
>
>
> #### 대기 | Wait
>
>
>
> - 프로세스에 I/O 처리가 필요하여 실행을 중단시키고, I / O 처리가 끝날 때까지 대기 중인 상태
> - I/O 가 완료되면 다시 준비상태로 전이(Wake Up)
>
>
>
> #### 종료 | Exit
>
>
>
> - 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태
>
>

`프로세스 상태 전이 용어`

>
>
>
> #### Dispatch
>
>
>
> - 준비상태에서 실행상태로 전이되는 과정
>
>
>
> #### Wake Up
>
>
>
> - 대기상태에서 준비상태로 전이되는 과정
>
>
>
> #### Spooling
>
>
>
> - 입/출력 데이터를 직접 입/출력 장치에 보내지 않고, 모아뒀다가 한꺼번에 입/출력하기 위해 디스크에 저장해놓는 과정
>
>

### 스레드 | Thread

`개념`

- 프로세스 내에서 실행되는 흐름의 단위

- 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 가짐

- 프로세스의 일부 특성을 가지고 있어 경량 프로세스라고도 함

- 스레드는 한 프로세스 내에서 동작되는 흐름으로 Stack 영역만 별도로 할당받고 부모 프로세스의 Code, Data, Head 영역은 공유

`특징`

- 프로그램의 일부분이 중단되어도 프로그램이 지속적으로 수행되어 응답성이 좋음

- 스레드들은 부모 프로세서의 자원과 메모리를 공유하여 자원 공유가 쉬움

- 프로세스를 할당하는 것보다 스레드를 할당하는 것이 비용이 적게 듬

- 멀티프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있음

- 구현 및 디버깅이 어려움

- 동기화 및 교착상태가 발생하지 않도록 주의해야 함

`분류`

- 사용자 수준의 스레드
  - 사용자가 만든 라이브러리를 사용하여 스레드를 운용
  - 속도는 빠르지만 구현이 어려움

- 커널 수준의 스레드
  - 운영체제의 커널에 의해 스레드를 운용
  - 구현이 쉽지만 속도가 느림

`문맥 교환 | Context Switching`

- 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 PCB에 보관하고 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정

- 문맥 교환은 멀티태스킹(=멀티프로세싱)이 가능하도록 해줌

- 하나의 CPU에서 여러 개의 프로세스가 동시에 수행되는 것처럼 보이는 이유는 문맥 교환이 빠르게 일어나기 때문

>
>
>
> #### 문맥 교환이 일어나는 시점
>
>
>
> - 멀티 테스킹
> - 인터럽트 처리
> - 사용자 및 커널 모드 전환
>
>

`프로세스 제어 블록 | Process Control Block`

- 운영체제가 프로세스에 대한 정보를 저장해 놓는 공간

- 각 프로세스가 생성될 때 마다 고유한 PCB가 생성되고, 프로세스가 완료되면 해당 PCB는 제거

>
>
>
> #### PCB에 저장되는 정보
>
>
>
> - 프로세스의 현재 상태(식별, 제어, 상태 정보)
> - 포인터(부모 프로세스, 자식 프로세스 등)
> - 프로세스 고유 식별자
> - 스케줄링, 프로세스 우선순위
> - CPU 레지스터 정보
> - 주기억장치 관리 정보
> - I/O 상태 정보
> - 계정정보(CPU 사용 시간, 실제 사용 시간, 한정된 시간)
>
>