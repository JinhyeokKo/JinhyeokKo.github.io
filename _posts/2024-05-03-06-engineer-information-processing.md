---
title: 06. 객체지향 설계
date: 2024-05-03
categories: [정보처리기사]
tags: [정보처리기사]
layout: post
---

## 객체지향 | Object Oriented Programming

### 개념

- 현실 세계의 유형, 무형의 모든 대상을 객체(Object)로 나누고, 객체의 행동(Method)과 고유한 값(Attribute)을 정의하여 설계하는 방법

- 객체를 만들고 조작하며 객체끼리 관계를 맺음으로써 다수의 객체가 함께 수행될 수 있게 함

### 구성요소

`클래스 | Class`

- 유사한 종류의 유형/무형의 존재를 묶어서 속성과 연산을 정의해서 만든 틀

- 다른 클래스와 독립적으로 디자인

- 데이터를 추상화하는 단위

`객체 | Object`

- 클래스의 인스턴스

- 객체는 자신 고유의 속성을 가지며, 클래스에서 정의한 연산을 수행

- 객체의 연산은 클래스에 정의된 연산에 대한 정의를 공유함으로써 메모리를 경제적으로 사용

`속성 | Attribute`

- 객체들이 가지고 있는 고유한 데이터를 단위별로 정의한 것

- 성질, 종류, 수량, 현재 상태 등에 대해 표현한 값

`메서드 | Method`

- 어떤 특정한 작업을 수행하기 위한 명령문의 집합

- 객체가 가지고 있는 속성들을 변경할 수 있는 하나의 연산

`메시지 | Message`

- 객체에게 어떤 행위를 하도록 지시

- 객체의 메서드를 호출함으로써 객체 간의 상호작용을 할 수 있도록 함

### 객체지향언어의 특징

`캡슐화 | Encapsulation`

- 데이터(Attribute)와 데이터를 처리하는 행동(Method)을 하나로 묶은 것

- 캡슐화된 객체의 세부내용은 외부에 은폐(정보은닉)되어, 오류의 파급 효과가 적음

- 캡슐화된 객체들은 재사용이 용이

- 객체들 간의 메시지를 주고받을 때, 해당 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고 결합도가 낮아짐

`정보은닉 | Information Hiding`

- 캡슐화의 가장 중요한 개념

- 다른 객체에게 자신의 데이터를 숨기고, 자신이 정의한 행동만을 통하여 접근을 허용

`상속 | Inheritance`

- 상위클래스(부모클래스)의 모든 데이터와 행동을 하위클래스가 물려받는 것

- 상속을 이용하면 하위클래스는 상위클래스의 데이터와 행동을 자신의 클래스에 다시 정의하지 않아도 됨

- 하위클래스는 상위클래스에서 상속받은 요소 외에 새로운 데이터와 행동을 추가하여 사용 가능

- 상위클래스의 요소들을 사용할 수 있기 떄문에, 소프트웨어 재사용을 증대시키는 중요한 개념

`다형성 | Polymorphism`

- 하나의 메시지에 대해 각 객체가 가지고 있는 여러 가지 방법으로 응답할 수 있는 개념
같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른형태의 특성을 가짐

객체에서 동일한 메서드명을 인자값의 유형이나 개수만 틀리게 하는 오버로딩이 존재
객체에서 상속받은 메서드를 재정의 하는 오버라이딩이 존재

`추상화 | Abstraction`

- 객체의 성질을 분해하고, 공통된 성질을 추출하여 슈퍼클래스를 설정하는 것

- 하위클래스들에 존재하는 공통적인 메서드를 상위클래스 혹은 인터페이스로 정의하고, 하위클래스가 해당 메서드를 재정의하는 것

### 설계 원칙 | SOLID

`단일 책임 원칙 | Single Responsibility Principle`

- 한 클래스는 하나의 책임만을 가져야 함

`개방 폐쇄 원칙 | Open-Closed Principle`

- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.

- 기존의 코드를 변경하지 않으면서(Closed), 기능을 추가할 수 있도록(Open) 설계

`리스코프 치환 원칙 | Liskov Substitution Principle`

- 자식 클래스는 언제나 자신의 부모클래스를 대체할 수 있어야 함

- 부모클래스가 들어갈 자리에 자식클래스를 넣어도 계획대로 작동해야 함

`인터페이스 분리 원칙 | Interface Segregation Principle`

- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함

- 자신이 사용하지 않는 인터페이스 때문에 영향을 받아서는 안됨

`의존관계 역전 원칙 | Dependency Inversion Principle`

- 의존관계를 맺을 때 자주 변화하는 것보다 변화가 거의 없는 것에 의존해야 함

- 구체적인 클래스보다 인터페이스나 추상 클래스와 의존 관계를 맺어야 함

---

## 디자인 패턴 | Design Pattern

### 개념

- 객체지향 프로그래밍을 설계할 때 자주 발생하는 문제들에 대해 재사용 할 수 있도록 만들어 놓은 패턴들의 모음

- 이미 만들어져서 잘 되는 것을 활용하여 재사용함으로써 프로그램 최적화에 도움을 줌

- 효율적인 코드를 만들기 위한 방법론

### 구성요소

- `패턴의 이름과 유형` : 패턴을 부를 때 사용하는 이름과 패턴의 유형

- `문제 및 배경` : 패턴이 사용되는 분야 또는 배경, 해결하는 문제

- `솔루션` : 패턴을 이루는 요소들, 관계, 협동 과정

- `사례` : 간단한 적용 사례

- `결과` : 패턴을 사용하면 얻게 되는 이점과 영향

- `샘플 코드` : 패턴이 적용된 원시 

### Gang Of Four 디자인 패턴

- `Erich Gamma, Richard Helm, Ralph Johnson, John Vissides` 에 의해 개발 영역에서 디자인 패턴을 구체화하고 체계화 시킴

- 23가지의 디자인 패턴을 정리

- 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류

### 생성 패턴 | Creational

- 객체의 생성과 관련된 패턴

- 객체의 인스턴스 생성을 추상화 하는 방법

- 객체의 생성과 참조과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 함

> 
> `Abstract Factory`
>
> - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
> 
> `Builder`
>
> - 복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어낼 수 있음
> 
> `Factory Method`
>
> - 상위 클래스에서 객체를 생성하는 인터페이스를 정의
> - 하위 클래스에서 어떤 클래스가 인스턴스화 될 것인지 결정
> - Virtual-Constructor 패턴 이라고도 함
> 
> `Prototype`
>
> - 원본 객체를 복사함으로써 객체를 생성
> 
> `Singleton`
>
> - 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함
> 
> 

### 구조 패턴 | Structural

- 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴

- 상속을 통해 클래스나 인터페이스를 합성하는 방법을 정의

>
> `Adapter`
>
> - 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함
> 
> `Bridge`
>
> - 기능의 클래스 계층과 구현의 클래스 계층을 분리하여 독립적으로 확장
>   - 구현부와 추상층을 분리
> 
> 
> `Composite`
>
> - 객체들의 관계를 트리구조로 구성하여 복합객체와 단일객체를 구분없이 다룸
> - 하나 이상의 유사한 객체를 구성으로 설계된 객체로 모두 유사한 기능을 나타냄
> 
> `Decorator`
>
> - 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식
> 
> `Facade`
>
> - 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공
> - 서브시스템의 가장 앞쪽에 위치하면서 서브시스템에 있는 객체들을 사용할 수 있도록 인터페이스 역할
> 
> `Flyweight`
>
> - 크기가 작은 여러개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약
> 
> `Proxy`
>
> - 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate(대리)나 Placeholder(대체글)를 제공
> 
> 

### 행위 패턴 | Behavioral

- 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한 패턴

- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하여 결합도를 최소화 할 수 있도록 도움

> 
> `Chain of Responsibility | 책임 연쇄`
>
> - 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달
> 
> `Command`
>
> - 요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장
> 
> `Interpreter`
>
> - 특정 언어의 문법 표현을 정의
> 
> `Iterator | 반복자`
>
> - 내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공
> 
> `Mediator | 중재자`
>
> - 한 집단에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의
> - 객체 간 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표 달성 도움
> 
> `Memento`
>
> - 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화
> 
> `Observer`
>
> - 객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함
> 
> `State`
>
> - 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용
> 
> `Strategy | 전략`
>
> - 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함
> 
> `Template Method`
>
> - 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 위임함
> 
> `Visitor`
>
> - 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성
> 
>