---
title: CPU 동작 원리
date: 2025-10-04
categories:
  - CS
tags:
  - 컴퓨터구조
layout: post
---

## CPU 동작 원리
### CPU 동작 원리 - 명령어 형태

- 연산 코드와 오퍼랜드로 구성되며 오퍼랜드 개수는 연산 코드에 따라 달라질 수 있음
  - `연산 코드` : 수행될 연산을 지정(산술 연산, 데이터 이동, 제어 명령 등)
  - `오퍼랜드` : 피연산자. 연산에 사용될 데이터 또는 데이터의 위치(레지스터, 메모리 주소, 특정 값)
- 명령어 길이(n 비트)도 CPU 종류에 따라 가변 또는 고정 길이를 가짐
  - `가변 길이` : 명령어마다 명령어 길이가 다름
  - `고정 길이` : 모든 명령어가 동일한 명령어 길이를 가짐

```
ADD R1, R2 // R1 레지스터와 R2 레지스터의 데이터를 더한다
연산 코드 - ADD
오퍼랜드 1 - R1 레지스터
오퍼랜드 2 - R2 레지스터
```

#### 기계어(Machine Code)
- CPU가 직접 실행하는 코드
- 인간이 읽기 어렵지만, CPU가 이해하는 가장 저수준의 명령어

#### 어셈블리어(Assembly Language)
- 인간이 읽고 작성할 수 있는 코드(C, Java, Python)와 컴퓨터가 이해할 수 있는 기계어(0 또는 1)의 중간 단계 언어
- 데이터 이동, 레지스터 조작, 메모리 접근 등 하드웨어를 직접 제어
- 어셈블리어는 1:1로 기계어 명령어에 대응
- ex) MOV AL, 1

### CPU 동작 원리 - 명령어 종류
#### 데이터 전송 명령어
- 데이터를 이동하는 명령
- `LOAD R1, 100` : 메모리 주소 100에서 데이터를 레지스터 R1으로 로드
- `STORE R1, 200` : 레지스터 R1의 데이터를 메모리 주소 200에 저장

#### 산술 및 논리 명령어
- 산술 연산과 논리 연산을 수행
- `SUB R1, R2` : R1에 R2의 값을 뺌
- `AND R1, R2` : R1과 R2의 비트를 AND 연산

#### 제어 명령어
- 프로그램 실행 순서를 변경하는 명령
- `JMP 400` : 프로그램을 주소 400으로 이동
- `BEQ R1, R2, 500` : R1과 R2가 같으면 주소 500으로 이동

#### 입출력 명령어
- 외부 장치와 데이터를 교환
- `IN R1, 0xFF` : 입력 장치 0xFF에서 데이터를 읽어 R1에 저장
- `OUT R1, 0xFF` : R1의 데이터를 출력 장치 0xFF로 보냄

### CPU 동작 원리 - 오퍼랜드 주소 지정 방식
- 데이터의 실제 값 또는 데이터가 저장된 주소를 저장

|       정의 내용       | 표기 방법 |
| :---------------: | :---: |
| 유효 주소(기억장치 실제 주소) |  EA   |
|     기억 장치 주소      |   A   |
|      레지스터 번호      |   R   |
|   기억장치 A 번지의 내용    |  (A)  |
|   레지스터 R 번지의 내용    |  (R)  |

#### 직접 주소 지정 방식
- `EA = A` 가장 기본적인 방식
- 오퍼랜드 필드의 내용이 데이터가 저장된 메모리의 실제 주소, 즉 유효주소
- 장점 : 데이터 인출을 위해 기억 장치에 1번만 접근
- 단점 : 오퍼랜드 필드의 비트 수에 의해 지정할 수 있는 기억 장소의 수가 제한

> 오퍼랜드 하나에 12비트가 할당되어 있다면 0~2^12 (=4096)
> 즉 범위를 벗어나는 주소에 접근해야 한다면 12비트로는 접근할 수 없음

#### 간접 주소 지정 방식
- EA = (A)
- 오퍼랜드 내용이 실제 데이터의 주소를 저장한 다른 주소를 나타냄
- 장점 : 주소를 동적으로 변경할 수 있어 유연성이 높음(데이터의 주소가 바뀌어도 A의 주소 값만 바꾸면 되고 명령어를 변경할 필요가 없음)
- 단점 : 기억 장치에 두 번(주소를 읽기 위해, 실제 데이터를 얻기 위해) 접근해야 해서 속도가 느림)

> 실제 데이터가 비트값을 넘어가는 B 주소에 저장되어 있다면, 비트값으로 접근할 수 있는 A 주소에 B 주소를 저장하여 접근

**직접 주소 지정 방식과 간접 주소 지정 방식의 비교**

|  직접 주소 지정 방식  |   간접 주소 지정 방식   |
| :-----------: | :-------------: |
| LOAD R1, 100  | LOAD R1, (200)  |
|  ADD R2, 100  |  ADD R2, (200)  |
| STORE 100, R3 | STORE (200), R3 |

- 직접 주소 지정 방식은 데이터가 주소 100에 저장되어 있으며 데이터 위치가 주소 200으로 변경되면, 모든 명령어에서 주소를 수정해야 함
- 간접 주소 지정 방식은 주소 200에는 실제 데이터가 저장된 주소(300)가 들어 있으므로 데이터의 위치가 300에서 400으로 변경될 경우 주소 200의 값만 수정하면 됨(200에 400 저장)

#### 즉시 주소 지정 방식
- 데이터가 명령어에 포함(오퍼랜드 필드의 내용이 실제 데이터)
- 장점 : 데이터를 찾아가기 위해 기억 장치에 접근할 필요가 없어 빠름
- 단점 : 오퍼랜드 필드의 비트 수에 의해 값의 크기가 제한됨

#### 레지스터 주소 지정 방식
- EA = R
- 데이터가 레지스터에 저장되어 있고, 오퍼랜드 내용이 레지스터 주소를 가리킴
- 장점 : 기억 장치에 접근할 필요가 없어 속도가 빠름(기억 장치 접근 속도보다 레지스터 접근 속도가 훨씬 빠름)
- 단점 : 데이터를 저장할 수 있는 공간이 CPU 내부의 레지스터로 제한됨

###  CPU 동작 원리 - 명령어 집합(Instruction Set)
- CPU가 이해하고 실행할 수 있는 명령어들의 모음
- CPU의 종류에 따라 명령어 집합은 달라질 수 있음

#### CISC
- x86 아키텍처(Intel, AMD) 기반 CPU의 명령어 집합
- 복잡하고 명령어로 구성되어 있고 명령어의 길이가 다양하고 명령어마다 명령어 실행 시간이 다름
- CISC의 명령어는 복잡한 대신 하나의 명령어가 많은 일을 할 수 있기 때문에 메모리를 절약할 수 있음

#### RISC
- ARM 등의 CPU의 명령어 집합
- 단순한 명령어로 구성되어 있고 명령어 길이가 고정
- 명령어 실행 속도가 빠르고 명령어마다 실행 시간이 대부분 일정

> 현대의 CPU는 RISC와 CISC의 장점을 결합한 혼합 설계를 주로 사용

| 특징        | CISC                        | RISC                                                                           |
| :-------- | :-------------------------- | :----------------------------------------------------------------------------- |
| 명령어 구조    | 복잡하고 다양한 명령어                | 간단하고 적은 수의 명령어                                                                 |
| 명령어 길이    | 가변                          | 고정                                                                             |
| 명령어 실행 시간 | 여러 클럭 사이클 소요 가능             | 대부분 1클럭 사이클                                                                    |
| 파이프라이닝    | 어려움                         | 최적화 쉬움                                                                         |
| 대표 CPU    | x86 아키텍처(Intel, AMD)        | ARM                                                                            |
| 응용 분야     | - 데스크톱 PC <br/>- 서버(데이터 센터) | - 스마트폰<br/>- 임베디드 시스템(가전제품, IoT 디바이스)<br/>- 랩탑(Apple M, Qualcomm Snapdragon X) |

**명령어 비교 예시**

- 고급 언어의 a = (b + c) \* d 연산을 각각의 방식으로 어셈블리어로 변환

```
// CISC 방식
MOV AX, [B]  ; 메모리 주소 B의 값을 AX 레지스터로 로드
ADD AX, [C]  ; 메모리 주소 C의 값을 AX에 더함(B + C)
IMUL AX, [D] ; 메모리 주소 D의 값을 AX와 곱함((B + C) * D)
MOV [A], AX  ; AX의 값을 메모리 주소 A에 저장

// RISC 방식
LDR R1, [B]    ; 메모리 주소 B의 값을 R1 레지스터에 로드
LDR R2, [C]    ; 메모리 주소 C의 값을 R2 레지스터로 로드
ADD R3, R1, R2 ; R1 + R2 결과를 R3에 저장 (B + C)
LDR R4, [D]    ; 메모리 주소 D의 값을 R4 레지스터로 로드
MUL R5, R3, R4 ; R3 * R4 결과를 R5에 저장 ((B + C) * D)
STR R5, [A]    ; R5의 값을 메모리 주소 A에 저장
```

