---
title: 데이터와 표현
date: 2025-10-02
categories:
  - CS
tags:
  - 컴퓨터구조
layout: post
math: true
updated: 2025-10-08
---

## 데이터의 가장 작은 단위 : 비트(bit)와 바이트(byte)
컴퓨터는 모든 정보를 0과 1의 조합인 **이진수(Binary)** 로 처리합니다. 전기 신호의 전압이 일정 기준보다 높으면 1, 그렇지 않다면 0으로 변환하여 사용합니다.

### 비트(Bit, b)
Binary Digit의 줄임말로, 컴퓨터가 데이터를 표현하는 가장 작은 단위입니다. 단 두 가지 상태, 0 또는 1만을 가질 수 있으며 이는 전기적 신호는 ON/OFF, 전압의 높고 낮음 등을 물리적으로 구현됩니다.

여러 개의 비트를 조합하여 숫자, 문자, 이미지 등 모든 종류의 데이터를 만들어 냅니다. n개의 비트가 있을 때 2의 n 제곱만큼 데이터를 표현할 수 있습니다.

### 바이트(Byte, B)
8개의 비트(8 bits)를 하나로 묶은 단위입니다. 즉 1바이트는 $2^{8} = 256$ 가지의 데이터를 표현할 수 있습니다. (0부터 255까지)

컴퓨터에서 데이터를 처리하거나 저장할 때 실질적인 기본 단위로 사용됩니다. 예를 들어, 메모리 주소를 지정할 때 바이트 단위를 사용합니다.

> **단위의 확장**
>   
> 바이트보다 큰 단위로는 킬로바이트(KB), 메가바이트(MB), 기가바이트(GB), 테라바이트(TB) 등이 있습니다. 기술적으로는 1KB가 $2^{10}$ 바이트(1024바이트)이지만, 저장장치 제조사는 계산의 편의를 위해 1000배로 계산하기도 합니다. 이로 인한 혼동을 피하기 위해 IEC 표준에서는 KiB(키비바이트), MiB(메비바이트) 같은 이진 접두사를 사용하기도 합니다.

#### 엔디안(Endianness)
엔디안은 1바이트보다 큰 데이터를 메모리에 저장하는 순서(Byte Order)를 의미합니다. CPU 아키텍처마다 방식이 달라 호환성 문제가 발생할 수 있습니다.

- **빅 엔디안 (Big-Endian)** : 사람이 숫자를 읽고 쓰는 방식과 같이, **가장 중요한 바이트(Most Significant Byte, MSB)** 를 메모리의 **낮은 주소**에 먼저 저장합니다. 네트워크 통신에서 표준으로 사용됩니다.
    
    > `0x12345678` → 주소 `100`번지부터 `12 34 56 78` 순으로 저장
    
- **리틀 엔디안 (Little-Endian)** : **가장 덜 중요한 바이트(Least Significant Byte, LSB)** 를 **낮은 주소**에 먼저 저장합니다. 대부분의 PC용 CPU(Intel, AMD)가 이 방식을 사용하며, 산술 연산에 유리한 측면이 있습니다.
    
    > `0x12345678` → 주소 `100`번지부터 `78 56 34 12` 순으로 저장

## 컴퓨터의 숫자 표현 - 정수(Integer)
정수는 소수점이 없는 숫자입니다. 컴퓨터는 부호 유무에 따라 정수를 다르게 표현합니다.

### 부호 없는 정수(Unsigned Integer)
0과 양의 정수만을 표현하며 주어진 비트를 모두 숫자 크기를 표현하는 데 사용합니다. 예로 8비트일 때 `00000000`은 0, `11111111`은 255를 의미하며, 총 256개($2^{8}$)의 숫자를 표현할 수 있습니다.

### 부호 있는 정수(Signed Integer)
양수, 0, 음수를 모두 표현해야 하므로, 가장 앞의 1비트(**최상위 비트, MSB**)를 **부호 비트(Sign Bit)** 로 사용합니다. 부호비트가 1이면 음수, 0이면 0 또는 양수를 나타냅니다.

#### 음수의 표현 방식
1. **부호와 절댓값(Sign-Magnitude)** : 부호 비트 뒤에 숫자의 절댓값을 그대로 쓰는 방식입니다. 직관적이지만 `+0` (`00000000`)과 `-0` (`10000000`)이 생기는 문제와 회로 구현이 복잡해져서 거의 쓰지 않습니다.
2. **1의 보수(1's Complement)** : 양수를 표현하는 비트를 모두 뒤집어서(0은 1로, 1은 0으로) 음수를 표현합니다. 이 방식 역시 `+0`과 `-0`이 존재하는 문제가 있습니다.
3. **2의 보수(2's Complement)** : 현재 모든 컴퓨터가 사용하는 방식입니다. 양수의 모든 비트를 반전시키고(1의 보수), 그 결과에 1을 더합니다.
	- 0이 하나뿐이며, 덧셈/뺄셈 연산을 동일한 회로로 처리할 수 있어 매우 효율적입니다.
	- n개의 비트로 표현할 수 있는 정수의 범위는 $-2^{n-1}$부터 $2^{n-1} - 1$까지이며, 예로 8비트는 -128부터 127까지 표현할 수 있습니다.

> **오버플로우(Overflow)**  
> 정수가 표현 가능한 범위를 넘어섰을 때 발생하는 현상입니다. 예를 들어 8비트 부호 있는 정수에서 `127` (`01111111`)에 1을 더하면, 결과는 `128`이 아닌 `-128` (`10000000`)이 됩니다. 이는 연산 결과의 부호 비트가 예상과 다를 때 탐지할 수 있습니다.

## 컴퓨터의 숫자 표현 - 실수(Floating-Point)
### 고정 소수점(Fixed-Point)
소수점의 위치를 미리 고정시켜 놓고 정수처럼 표현하는 방식입니다. 간단하지만 표현 범위가 매우 제한적이라 특수한 임베디드 시스템 등에서만 사용됩니다.

### 부동 소수점(Floating-Point)
국제 표준 IEEE 754의 부동소수점 표현 방식으로 실수를 표현하고 저장하는 대부분의 시스템이 사용하는 표준 방식입니다. 과학적 표기법($M \times B^{E}$)과 유사하게 수를 표현하며 컴퓨터는 이것을 2진수($\pm(1.M) \times 2^{E-Bias}$)로 표현합니다.

#### IEEE 754
가장 최상위 비트를 부호비트로 사용하고, 나머지 비트를 값의 범위(자릿수)를 나타내는 2의 거듭제곱수를 저장하는 지수(Exponent, E) 필드와 유횻값(정밀도)을 나타내기 위해 실제 숫자의 유효한 자릿수를 저장하는 가수(Mantissa, M) 필드로 분리합니다.

- **단정도(Single Precision, 32비트)**
	- 부호 : 최상위 1bit(31번째 비트), 0은 양수를 1은 음수를 표현
	- 지수 : 8bit(23~30번째 비트), $2^{8}$개 표현 가능, Bias(127)를 더한 값으로 저장하여 음수 지수도 표현
	- 가수 : 23bit(0~22번째 비트),  $2^{23}$개 표현 가능, 정규화 후 `1.` 을 제외한 소수점 이하 부분만 저장

- **배정도(Double precision, 64비트)**
	- 부호 : 최상위 1bit(63번째 비트)
	- 지수 : 11bit(52~62번째 비트), $2^{11}$개 표현 가능
	- 가수 : 52bit(0~51번째 비트),  $2^{23}$개 표현 가능

```
// 실수의 2진수 표현
정수 부분은 2진법으로 변환한다.
소수 부분은 소수 부분이 0이 될 때까지 2를 곱하여 계산마다 나오는 정수 부분만 순서대로 밟는다.
// EXAMPLE
7.3125를 이진수로 표현 시
정수 부분 7은 0111
소수 부분 0.3125는
0.3125 * 2 = 0.625
0.625 * 2 = 1.25
0.25 * 2 = 0.5
0.5 * 2 = 1.0
정수 부분만 취하여 0101
즉 0111.0101

// 실수 저장
1. 지숫값만큼 소수점을 앞으로 옮겨주는 정규화 수행
   0111.0101의 경우 01.110101 * 2의 제곱
2. 음수 표현을 위해 지수에 특정 값(Bias)을 더해서 저장
   32비트에서는 Bias가 127이므로 00000010 + 01111111 = 10000001이 지수부에 저장
3. 정규화된 가수 1.110101에서 정수 부분인 1은 항상 존재한다고 가정하고 생략(이를 "Hidden Bit"라고 함)하며 소수점 아랫부분인 110101만 저장하고 나머지 비트는 0으로 채움

// 결과
원래 숫자 - 7.3125
2진수 표현 - 111.0101
정규화 - 1.110101 * 2^2
부호 - + (양수)
지수 - 2
가수 - 1.110101
IEEE 754(32bit) - 0 10000001 11010100000000000000000
```

> **부동 소수점 오차**
>   
> 가수가 표현할 수 있는 비트 수가 유한하기 때문에, 원주율(π) 같은 무한 소수는 정확한 값을 저장하지 못하고 근사치로 저장됩니다. 이로 인해 미세한 **정밀도 오차**가 발생할 수 있으며, 금융 계산 등 높은 정확도가 필요할 때는 주의해야 합니다.

> IEEE 754 표준은 지수부의 비트 패턴에 따라 특별한 값을 표현할 수 있습니다.
> - **0** : 지수와 가수가 모두 0.
> - **무한대 (Infinity)** : 지수가 모두 1, 가수가 모두 0. (e.g., 1.0 / 0.0)
> - **NaN (Not a Number)** : 지수가 모두 1, 가수가 0이 아님. (e.g., 0.0 / 0.0)

## 컴퓨터의 문자 표현
컴퓨터는 문자도 숫자로 변환하여 저장하며, 어떤 숫자를 어떤 문자에 대응시킬지에 대한 규칙을 **문자 인코딩(Character Encoding)** 이라고 합니다.

### 아스키코드(ASCII)
미국 정보 교환 표준 부호로, 초창기 컴퓨터의 표준 문자 인코딩입니다.  
7비트를 사용하여 총 128개($2^{8}$)의 문자를 표현(보통 1바이트에 저장)하며 오류 검출을 위한 패리티 비트에 해당하는 1비트를 포함하여 총 8비트로 구성됩니다.

하나의 문자는 하나의 번호에 대응하며 문자 A를 숫자 65로 변환하는 것을 인코딩, 숫자 65를 해석하여 문자 A로 변환하는 것을 디코딩이라고 합니다.

#### 패리티 비트(Parity Bit)
비트의 마지막에 추가하며 8비트 내의 1의 개수를 짝수로 맞춰 오류를 검출합니다.

> `1010001`의 경우 마지막 1을 추가하여 `10100011`로 만들어 1의 개수를 짝수로 맞춤  
> `11100011` 이 될 경우 홀수개가 되어 오류로 판단  
>   
> 하지만 짝수개의 비트 변환이 있을 때 오류검출이 불가능한 한계점을 가짐

### 유니코드(Unicode)
아스키는 영문 외의 언어를 표현할 수 없다는 한계가 있었습니다. 이를 해결하기 위해 전 세계의 모든 문자에 고유한 코드 포인트(숫자)를 부여하는 국제 표준인 **유니코드(Unicode)** 가 등장했습니다.

> 초기엔 16비트였으나 표현할 문자나 이모티콘이 많아져 지금은 21비트로 증가

#### 유니코드 표현 방법
- 비트를 4개씩 나눠서 16진법(4비트)으로 표현
- 16진법을 사용하는 경우 맨 앞에 `U+`를 붙여 표시
- 코드 포인트 : `U+0000` ~ `U+10FFFF`(10진법으로 약 111만)

### UTF-8
유니코드 코드 포인트를 실제 메모리에 저장하는 가변 길이 인코딩 방식 중 하나로, 현재 웹에서 가장 널리 사용되는 표준입니다.

아스키코드에 해당하는 영문, 숫자는 1바이트(자주 쓰는 문자를 1바이트로 처리하여 용량을 절약)로 표현하여 호환성을 유지하고 한글과 같은 다른 문자들은 2~4바이트를 사용하여 표현합니다.

|      유니코드      |  UTF-8   |          |          |          |
| :------------: | :------: | :------: | :------: | :------: |
|     코드값 범위     |   1바이트   |   2바이트   |   3바이트   |   4바이트   |
|  0000 ~ 007F   | 0xxxxxxx |          |          |          |
|  0080 ~ 07FF   | 110xxxxx | 10xxxxxx |          |          |
|  0800 ~ FFFF   | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
| 10000 ~ 10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |

> - 한글의 경우 `U+AC00`부터 시작하므로 `0800` ~ `FFFF` 구간에 해당하기 때문에 UTF-8으로 인코딩 시 3바이트로 저장
> - 16진법의 `AC00`을 이진법으로 나타내면 `1010 1100 0000 0000`이기 때문에 표에 표시된 x에 대응하게 되어 인코딩 결과는 `11101010 10110000 10000000`이 된다.

