---
title: 데이터와 표현
date: 2025-10-02
categories:
  - CS
tags:
  - 컴퓨터구조
layout: post
---

## 데이터와 표현
### 비트와 바이트
- 컴퓨터는 10진법이 아닌 2진법을 사용해 정보를 저장하기 때문에 0과 1만을 저장
- 전기 신호의 전압이 일정 기준보다 높으면 1, 그렇지 않다면 0으로 변환하여 사용

#### 비트
- 0과 1을 표현할 수 있는 최소 단위이며 여러 개의 비트를 조합하여 데이터를 표현
- n개의 비트가 있을 때 2의 n 제곱만큼 데이터를 표현 가능

#### 바이트
* 8비트를 한 묶음으로 표현한 단위. 즉 1바이트당 256(2의 8제곱)가지의 데이터 표현이 가능

### 컴퓨터의 숫자 표현 - 정수
#### 음수의 표현
- 부호 비트
  - 컴퓨터는 n 비트에서 가장 왼쪽의 비트(최상위 비트)를 부호 비트로 사용하여 음수를 표현
  - 부호 비트가 1이면 음수, 0이면 0 또는 양수
- 2의 보수
  - 음수를 저장하기 위해 사용하는 방법
  - 모든 비트를 반전시키고 1을 더함
  - n개의 비트로 표현할 수 있는 정수의 범위는 -2의 n-1 제곱부터 2의 n-1 제곱 -1까지
  - 4비트의 경우 1000(-8)부터 0111(7)까지 데이터 표현이 가능

### 컴퓨터의 숫자 표현 - 실수
#### 부동 소수점
- 국제 표준 IEEE 754의 부동소수점 표현 방식으로 실수를 표현하고 저장
- 32비트 기준으로 가장 최상위 비트를 부호비트로 사용하고, 나머지 31개 비트를 지수 필드와 가수 필드로 분리
- 지수(E) 필드는 값의 범위를 나타내는 2의 거듭제곱수를 저장
   - 23~30번째 비트, 256개 표현 가능
- 가수(M) 필드는 정밀도를 나타내기 위해 실제 숫자의 유효한 자릿수를 저장
  - 0~22번째 비트, 2의 23제곱 개의 표현 가능

```
// 실수의 2진수 표현
정수 부분은 2진법으로 변환한다.
소수 부분은 소수 부분이 0이 될 때까지 2를 곱하여 각 계산마다 나오는 정수 부분만 순서대로 취한다.
// EXAMPLE
7.3125를 이진수로 표현 시
정수 부분 7은 0111
소수 부분 0.3125는
0.3125 * 2 = 0.625
0.625 * 2 = 1.25
0.25 * 2 = 0.5
0.5 * 2 = 1.0
정수 부분만 취하여 0101
즉 0111.0101

// 실수 저장
1. 지수값 만큼 소수점을 앞으로 옮겨주는 정규화 수행
   0111.0101의 경우 01.110101 * 2의 제곱
2. 음수 표현을 위해 지수에 특정 값(Bias)을 더해서 저장
   32비트에서는 Bias가 127이므로 00000010 + 01111111 = 10000001이 지수부에 저장
3. 정규화된 가수 1.110101에서 정수 부분인 1은 항상 존재한다고 가정하고 생략(이를 "Hidden Bit"라고 함)하며 소수점 아래부분인 110101만 저장하고 나머지 비트는 0으로 채움

// 결과
원래 숫자 - 7.3125
2진수 표현 - 111.0101
정규화 - 1.110101 * 2^2
부호 - + (양수)
지수 - 2
가수 - 1.110101
IEEE 754(32bit) - 0 10000001 11010100000000000000000
```

> 실수를 저장하기 위한 비트가 한정되어 있어 모든 실수 저장 불가.  
> 예를 들어 파이와 같은 무한소수의 경우 정확한 저장 불가

### 컴퓨터의 문자 표현
#### 아스키 코드
- 128개의 문자 조합을 제공하는 7비트 부호
- 오류 검출을 위한 패리티 부호에 해당하는 1비트를 포함하여 총 8비트로 구성
- 하나의 문자는 하나의 번호에 대응
- 문자 A를 숫자 65로 변환하는 것을 인코딩
- 숫자 65를 해석하여 문자 A로 변환하는 것을 디코딩

> **패리티 부호**  
> - 오류 검출을 위한 비트
> - 비트 마지막에 추가
> - 1의 개수를 짝수로 맞춤(짝수 패리티 부호)
> 
> 1010001의 경우 마지막 1을 추가하여 10100011로 만들어 1의 개수를 짝수로 맞춤  
> 11100011 이 될 경우 홀수개가 되어 오류로 판단  
> 하지만 짝수개의 비트변환이 있을 경우 오류검출이 불가능한 한계점을 가짐

#### 유니코드
- 아스키 코드는 미국의 표준이라 타 언어를 표현하는 데 한계
- 전 세계 문자를 동일한 방법으로 표현하기 위해 1995년 유니코드가 국제 표준으로 제정됨
- 초기엔 16비트였으나 표현할 문자나 이모티콘이 많아져 지금은 21비트로 증가

> **유니코드 표현 방법**  
> - 비트를 4개씩 나눠서 16진법(4비트)으로 표현
> - 16진법을 사용하는 경우 맨 앞에 U+를 붙여 표시
> - U+0000 ~ U+10FFFF(10진법으로 약 111만)

#### UTF-8
- 유니코드에 대해 가변 길이 인코딩을 수행
- 인코딩 결과는 1바이트~4바이트가 가능
- 자주 쓰는 문자를 1바이트로 처리하여 용량을 절약
- 1바이트 문자는 아스키 코드와 호환

|      유니코드      |  utf-8   |          |          |          |
| :------------: | :------: | :------: | :------: | :------: |
|     코드값 범위     |   1바이트   |   2바이트   |   3바이트   |   4바이트   |
|  0000 ~ 007F   | 0xxxxxxx |          |          |          |
|  0080 ~ 07FF   | 110xxxxx | 10xxxxxx |          |          |
|  0800 ~ FFFF   | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
| 10000 ~ 10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |

> - 한글의 경우 U+AC00부터 시작하므로 0800 ~ FFFF 구간에 해당되기 때문에 utf-8로 인코딩 시 3바이트로 저장
> - 16진법의 AC00을 이진법으로 나타내면 1010 1100 0000 0000이기 때문에 표에 표시된 x에 대응되게 되어  인코딩 결과는 11101010 10110000 10000000이 된다