---
title: 데이터와 표현
date: 2025-10-02
categories:
  - CS
tags:
  - 컴퓨터구조
layout: post
math: true
updated: 2025-10-08
---

## 데이터의 가장 작은 단위 : 비트(bit)와 바이트(byte)
컴퓨터는 모든 정보를 0과 1의 조합인 **이진수(Binary)** 로 처리합니다.  
전기 신호의 전압이 일정 기준보다 높으면 1, 그렇지 않다면 0으로 변환하여 사용합니다.

### 비트(Bit, b)
Binary Digit의 줄임말로, 컴퓨터가 데이터를 표현하는 가장 작은 단위입니다.  
단 두 가지 상태, 0 또는 1만을 가질 수 있으며 이는 전기적 신호는 ON/OFF, 전압의 높고 낮음 등을 물리적으로 구현됩니다.  
여러 개의 비트를 조합하여 숫자, 문자, 이미지 등 모든 종류의 데이터를 만들어 냅니다.
n개의 비트가 있을 때 2의 n 제곱만큼 데이터를 표현할 수 있습니다.

### 바이트(Byte, B)
8개의 비트(8 bits)를 하나로 묶은 단위입니다. 즉 1바이트는 $2^{8} = 256$ 가지의 데이터를 표현할 수 있습니다. (0부터 255까지)  
컴퓨터에서 데이터를 처리하거나 저장할 때 실질적인 기본 단위로 사용됩니다. 예를 들어, 메모리 주소를 지정할 때 바이트 단위를 사용합니다.

> **단위의 확장**  
>   
> 바이트보다 더 큰 단위로는 킬로바이트(KB), 메가바이트(MB), 기가바이트(GB), 테라바이트(TB) 등이 있습니다. 보통 1024배($2^{10}$)씩 커지는데, 저장장치 제조사는 계산의 편의를 위해 1,000배로 계산하기도 해서 용량 표시에 차이가 생길 수 있습니다. (KiB, MiB 등 별도 단위도 존재)

## 컴퓨터의 숫자 표현 - 정수(Integer)
정수는 소수점이 없는 숫자입니다. 컴퓨터는 부호가 있는지 없는지에 따라 정수를 다르게 표현합니다.

### 부호 없는 정수(Unsigned Integer)
0과 양의 정수만을 표현하며 주어진 비트를 모두 숫자 크기를 표현하는 데 사용합니다. 예로 8비트일 때 `00000000`은 0, `11111111`은 255를 의미하며, 총 256개($2^{8}$)의 숫자를 표현할 수 있습니다.

### 부호 있는 정수(Signed Integer)
양수, 0, 음수를 모두 표현해야 하므로, 가장 앞의 1비트(최상위 비트)를 **부호 비트(Sign Bit)** 로 사용합니다. 부호비트가 1이면 음수, 0이면 0 또는 양수를 나타냅니다.

#### 음수의 표현 방식
1. **부호와 절댓값(Sign-Magnitude)** : 부호 비트 뒤에 숫자의 절댓값을 그대로 쓰는 방식입니다. 직관적이지만 `+0` (`00000000`)과 `-0` (`10000000`)이 생기는 문제와 회로 구현이 복잡해져서 거의 쓰지 않습니다.
2. **1의 보수(1's Complement)** : 양수를 표현하는 비트를 모두 뒤집어서(0은 1로, 1은 0으로) 음수를 표현합니다. 이 방식 역시 `+0`과 `-0`이 존재하는 문제가 있습니다.
3. **2의 보수(2's Complement)** : 현재 모든 컴퓨터가 사용하는 방식입니다. 양수의 모든 비트를 반전시키고(1의 보수), 그 결과에 1을 더합니다.
	- 0이 하나뿐이며, 덧셈/뺄셈 연산을 동일한 회로로 처리할 수 있어 매우 효율적입니다.
	- n개의 비트로 표현할 수 있는 정수의 범위는 -2의 n-1 제곱부터 2의 n-1 제곱 -1까지이며, 예로 8비트는 -128부터 127까지 표현할 수 있습니다.

> **Overflow**  
> 정수 표현 범위를 넘어가는 연산을 할 때 발생하며 8비트 부호 있는 정수에서 `127 + 1`을 계산하면 `128`이 아닌 `-128`이 되는 현상

## 컴퓨터의 숫자 표현 - 실수(Floating-Point)
### 고정 소수점(Fixed-Point)
소수점의 위치를 미리 정해놓고 표현하는 방식입니다. 간단하지만 표현할 수 있는 수의 범위가 매우 제한적이라 특수한 경우에만 사용됩니다.

### 부동 소수점(Floating-Point)
국제 표준 IEEE 754의 부동소수점 표현 방식으로 실수를 표현하고 저장하는 대부분의 시스템이 사용하는 표준 방식입니다.  
과학적 표기법($M \times B^{E}$)과 유사하게 수를 표현하며 컴퓨터는 이것을 2진수($\pm(M) \times 2^{E}$)로 표현합니다.

#### IEEE 754
가장 최상위 비트를 부호비트로 사용하고, 나머지 비트를 값의 범위(자릿수)를 나타내는 2의 거듭제곱수를 저장하는 지수(Exponent, E) 필드와 유횻값(정밀도)을 나타내기 위해 실제 숫자의 유효한 자릿수를 저장하는 가수(Mantissa, M) 필드로 분리합니다.

> **단정도(Single Precision)** : 32비트
> - 부호 : 최상위 1bit(31번째 비트)
> - 지수 : 8bit(23~30번째 비트), $2^{8}$개 표현 가능
> - 가수 : 23bit(0~22번째 비트),  $2^{23}$개 표현 가능
>   
> **배정도(Double precision)** : 64비트
> - 부호 : 최상위 1bit(63번째 비트)
> - 지수 : 11bit(52~62번째 비트), $2^{11}$개 표현 가능
> - 가수 : 52bit(0~51번째 비트),  $2^{23}$개 표현 가능

```
// 실수의 2진수 표현
정수 부분은 2진법으로 변환한다.
소수 부분은 소수 부분이 0이 될 때까지 2를 곱하여 계산마다 나오는 정수 부분만 순서대로 밟는다.
// EXAMPLE
7.3125를 이진수로 표현 시
정수 부분 7은 0111
소수 부분 0.3125는
0.3125 * 2 = 0.625
0.625 * 2 = 1.25
0.25 * 2 = 0.5
0.5 * 2 = 1.0
정수 부분만 취하여 0101
즉 0111.0101

// 실수 저장
1. 지숫값만큼 소수점을 앞으로 옮겨주는 정규화 수행
   0111.0101의 경우 01.110101 * 2의 제곱
2. 음수 표현을 위해 지수에 특정 값(Bias)을 더해서 저장
   32비트에서는 Bias가 127이므로 00000010 + 01111111 = 10000001이 지수부에 저장
3. 정규화된 가수 1.110101에서 정수 부분인 1은 항상 존재한다고 가정하고 생략(이를 "Hidden Bit"라고 함)하며 소수점 아랫부분인 110101만 저장하고 나머지 비트는 0으로 채움

// 결과
원래 숫자 - 7.3125
2진수 표현 - 111.0101
정규화 - 1.110101 * 2^2
부호 - + (양수)
지수 - 2
가수 - 1.110101
IEEE 754(32bit) - 0 10000001 11010100000000000000000
```

> 가수 부분이 표현할 수 있는 자릿수에 한계가 있어 **정밀도 오차** 가 발생할 수 있습니다.  
> 예를 들어 파이와 같은 무한소수의 경우 정확한 저장이 불가능합니다.

## 컴퓨터의 문자 표현
컴퓨터는 문자도 숫자로 바꿔서 기억합니다. 어떤 숫자를 어떤 문자에 대응시킬지에 대한 규칙을 **문자 인코딩(Character Encoding)** 이라고 합니다.
### 아스키코드(ASCII)
미국 정보 교환 표준 부호로, 초창기 컴퓨터의 표준 문자 인코딩입니다.  
7비트를 사용하여 총 128개($2^{8}$)의 문자를 표현(보통 1바이트에 저장)하며 오류 검출을 위한 패리티 비트에 해당하는 1비트를 포함하여 총 8비트로 구성됩니다.  
하나의 문자는 하나의 번호에 대응하며 문자 A를 숫자 65로 변환하는 것을 인코딩, 숫자 65를 해석하여 문자 A로 변환하는 것을 디코딩이라고 합니다.

#### 패리티 비트(Parity Bit)
비트의 마지막에 추가하며 8비트 내의 1의 개수를 짝수로 맞춰 오류를 검출합니다.

> `1010001`의 경우 마지막 1을 추가하여 `10100011`로 만들어 1의 개수를 짝수로 맞춤  
> `11100011` 이 될 경우 홀수개가 되어 오류로 판단  
>   
> 하지만 짝수개의 비트 변환이 있을 때 오류검출이 불가능한 한계점을 가짐

### 유니코드(Unicode)
아스키코드의 타 언어를 표현할 수 없는 한계를 해결하고자 전 세계 문자를 동일한 방법으로 표현하고 다룰 수 있도록 설계된 국제 표준입니다.

> 초기엔 16비트였으나 표현할 문자나 이모티콘이 많아져 지금은 21비트로 증가

#### 유니코드 표현 방법
- 비트를 4개씩 나눠서 16진법(4비트)으로 표현
- 16진법을 사용하는 경우 맨 앞에 `U+`를 붙여 표시
- 코드 포인트 : `U+0000` ~ `U+10FFFF`(10진법으로 약 111만)

### UTF-8
유니코드 코드 포인트를 실제 메모리에 저장하는 방식(가변 길이 인코딩 수행) 중 하나로, 현재 웹에서 가장 널리 사용되는 표준입니다.  
아스키코드에 해당하는 영문, 숫자는 1바이트(자주 쓰는 문자를 1바이트로 처리하여 용량을 절약)로 표현하여 호환성을 유지하고 한글과 같은 다른 문자들은 2~4바이트를 사용하여 표현합니다.

|      유니코드      |  UTF-8   |          |          |          |
| :------------: | :------: | :------: | :------: | :------: |
|     코드값 범위     |   1바이트   |   2바이트   |   3바이트   |   4바이트   |
|  0000 ~ 007F   | 0xxxxxxx |          |          |          |
|  0080 ~ 07FF   | 110xxxxx | 10xxxxxx |          |          |
|  0800 ~ FFFF   | 1110xxxx | 10xxxxxx | 10xxxxxx |          |
| 10000 ~ 10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |

> - 한글의 경우 `U+AC00`부터 시작하므로 `0800` ~ `FFFF` 구간에 해당하기 때문에 UTF-8으로 인코딩 시 3바이트로 저장
> - 16진법의 `AC00`을 이진법으로 나타내면 `1010 1100 0000 0000`이기 때문에 표에 표시된 x에 대응하게 되어 인코딩 결과는 `11101010 10110000 10000000`이 된다.

