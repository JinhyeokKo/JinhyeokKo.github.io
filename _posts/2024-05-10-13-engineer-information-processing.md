---
title: 13. 제품 소프트웨어 버전관리
date: 2024-05-10
categories: [정보처리기사]
tags: [정보처리기사]
layout: post
---

## 소프트웨어 버전관리 도구

### 개념

- 동일한 소스 코드에 대한 여러 버전을 관리하는 것

- 개발중인 소스코드나 설계 문서 등의 디지털 문서를 관리하는 데 사용

- 문서의 변경 사항들에 숫자나 문자로 이루어진 버전을 부여해서 구분

- 버전을 통해서 변경된 시간과 변경된 내용, 작업자를 추적

### 유형

`공유 폴더 방식`

- 매일 개발 완료 파일은 약속된 위치의 공유폴더에 복사

- 담당자 한 명이 매일 공유 폴더의 파일을 자기 PC로 복사하고 컴파일하여 에러 확인과 정상 동작 여부 확인

- 정상 동작일 경우 다음날 각 개발자들이 동작 여부 확인

- 종류 : RCS, SCCS, PVCS, QVCS 등

`클라이언트/서버 방식`

- 중앙에 버전 관리 시스템이 항시 동작

- 개발자들의 현재 작업 내용과 이전 작업내용 축적 용이

- 서로 다른 개발자가 같은 파일을 작업했을 때 경고 출력

- 종류 : CVS, SVN, Clear Case 등

`분산 저장소 방식`

- 로컬 저장소와 원격 저장소 구조

- 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업

- 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 가능

- 종류 : Git, Betkeeper 등

### 특징

`CVS`

- 오랜 기간 사용된 형상 관리 도구로 다양한 운영체제 지원

- 중앙에 위치한 Repository에 파일을 저장하고, 인가된 모든 사용자가 파일에 접근 가능

- 파일의 히스토리를 보존하기 때문에 과거 이력을 확인 가능

- Commit 중 오류가 발생하면 롤백 불가

- 다른 개발자가 작업 중인 파일에 덮어쓰기가 방지

- 상대적으로 속도 느림

- 등록된 파일이나 디렉토리의 변동 불편

`SVN`

- CVS의 단점을 보안하기위해 제작

- 최초 1회에 한해 파일 원본을 저장하고, 그 이후에는 실제 파일이 아닌 원본과 차이점을 저장하는 방식

- 언제든지 원하는 시점으로 복구 가능

- Commit 실패 시 롤백 가능

- Trunk, Branches, Tags 의 폴더로 구성하여 형상 관리

`Git`

- 리누스 토발즈가 리눅스 커널의 개발을 위해 제작

- 원격 서버 Git Repository에 push 하지 않은 채 여러 branch 생성가능

- 로컬 우선 작업을 통해 성능이 SVN, CVS보다 우수

- 팀 개발을 위한 분산 환경 코딩에 최적화

- 원격 Repository에 장애가 있어도 버전 관리 가능

`Clear Case`

- IBM에서 개발된 유료 버전의 형상 관리 툴

- 서버가 부족할 때 서버를 하나씩 늘려 확장 가능

`RCS | Revision Control System`

- 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일을 잠금하는 방식으로 버전 컨트롤을 수행

### 주요 용어

`Repository` : 버전 저장소  
`Checkin` : 변경된 컴포넌트들을 Repository에 반영하는 것  
`Checkout` : Repository에서 로컬로 프로젝트를 복사  
`Commit` : 로컬의 변경된 내용을 Repository에 저장  
`Update` : Repository에 있는 내용을 로컬에 반영  
`Add` : 로컬에서 새로운 파일이 추가되었을 때 Repository에 등록  
`Trunk` : Root 프로젝트  
`Branch` : Root 프로젝트에서 파생된 프로젝트 | 동일한 컴포넌트를 다른 목적으로 독립적인 개발 시 사용  
`Merge` : Branch에서 진행하던 작업을 Root 프로젝트와 합침 | 병합 시 `Conflict` 발생 가능  
`Diff` : 파일의 비교  
`Delta` : 컴토넌트의 버전 간 차이  
`Forward Delta` : 어떤 버전으로부터 이후 버전을 생성하기 위한 규칙  
`Backward Delta` : 어떤 버전으로부터 이전 버전을 생성하기 위한 규칙  
`Baseline` : 특정 시점에서 만들어진 완전한 산출물  

### 동작

- 프로젝트 시작 시 프로젝트에 사용될 프레임워크, 기본 문서들을 최초로 `불러오기 | Import`

- 프로젝트 참여자들은 각자의 계정을 생성하고, 모든 파일을 `인출 | Checkout`

- 참여자는 새로운 파일 생성 시 해당 파일을 버전 관리 시스템에 `추가 | Add`

- 참여자는 기존 파일 수정 시 수정된 내용을 저장소에 `저장 | Commit`

- 참여자는 로컬에 있는 파일과 다른 버전의 파일이나 신규 파일들을 `동기화 | Update`

- 동기화 시 두 파일의 내용을 `비교 | Diff`

### 사용 유의점

- 형상관리 지침에 의거 버전에 대한 정보를 언제든지 접근 가능해야 함

- 제품 소프트웨어 개발자, 배포자 이외에 불필요한 사용자가 소스를 수정할 수 없도록 해야 함

- 동일한 프로젝트에 대해서 여러 개발자가 동시에 개발 할 수 있어야 함

- 에러 발생 시 최대한 빠른 시간 내에 복구해야 함

### 백업 & 복구

- 정전, 사이버 공격 및 다른 중단 사태에 대비하여 복구를 진행할 수 있도록 데이터를 주기적으로 복구하는 것을 의미

- 복구 시간 목표(RTO)와 복구 시점 목표(RPO)를 충족하기 위한 다양한 방법 존재

`재난 복구 전략 시 성과 지표`

> 
> 
> 
> #### RTO | Recovery Time Objective
> 
> 
>
> - 업무 중단 시점부터 복구되어 가동될 때 까지의 시간 목표
> - 시스템 장애 시 비즈니스가 감당할 수 있는 최대 시간
> - 복구 완료가 필요한 기능의 우선순위
> 
> 
> 
> #### RPO | Recovery Point Objective
> 
> 
>
> - 재해 발생 시 데이터 손실의 수용 손실 허용 시점
> - 얼마만큼의 데이터 손실을 감당할 수 있는지 의미
> - 서비스 중단에 따른 데이터 보호 계획
> 
> 
> 
> #### MTD | Maximum Tolerable Downtime
> 
> 
>
> - 비즈니스 연속성 관리에서 사용되는 지표
> - 장애 시 업무가 정지 상태를 허용하는 최대 시간
> - 서비스를 중단할 수 있는 최소 시간
> 
> 
> 
> #### MTTR | Mean Time To Repair
> 
> 
>
> - 실제 업무 기능 복구까지 걸리는 시간
> 
>

`백업과 복구를 위한 전략`

> 
> 
> 
> #### 풀 이미지 백업
> 
> 
> 

> - 데이터의 풀 이미지를 백업하여 즉각적으로 이용할 수 있는 복구 시점을 생성

> - 전체 백업을 수행하기 때문에 가장 오랜 시간 소요

> 
> 
> 
> #### 차등 백업 | Differential
> 
> 
>
> - 마지막 풀 이미지 백업 이후부터 발생한 모든 변경 사항을 백업
> - 복구에는 마지막 풀 이미지 백업과 최신 차등 백업이 필요
> 
> 
> 
> #### 증분 백업 | Incremental
> 
> 
>
> - 마지막 풀 이미지 복구 시점 이후부터 변경된 사항을 점차적으로 백업
> 
> 
> 
> #### 실시간 백업
> 
> 
>
> - 지속적인 백업으로도 불리며 즉각적으로 모든 변경사항을 분리된 스토리지 디바이스에 복사
> 
> 
> 
> #### 합성 백업 | Synthetic
> 
> 
>
> - 기본 백업과 후속 증분 백업으로부터 전체 백업을 구성하거나 통합하는 방식
> 
> 
> 
> #### 중복제거 백업 | Deduplication
> 
> 
>
> - 서로 다른 데이터들 간에 중복되는 부분을 검출해내고 백업 파일 저장 시 중복된 부분을 제거한 후 저장
> 
> 

---

## 빌드 자동화 도구

### 개념

- 소스코드 파일들을 컴퓨터에서 실행할 수 있는 소프웨어로 변환하는 일련의 과정

- 빌드의 단계 중 컴파일이 포함되어 있는데 컴파일은 빌드의 부분집합

- 빌드 과정을 도와주는 도구를 빌드 툴이라고 함

- 빌드 자동화 도구는 지속적인 통합(Continuous Integration)을 수행할 수 있도록 도움

### 특징

- 빌드, 테스트, 배포를 자동으로 수행하는 도구

- 소스 코드를 컴파일, 테스트, 정적분석 등을 실시하여 실행 가능한 애플리케이션을 자동으로 생성

- 계속해서 늘어나는 라이브러리 자동 추가 및 관리

- 프로젝트를 진행하며 시간이 지남에 따라 라이브러리의 버전을 자동으로 동기화

### 프로세스

`빌드`

- 개발자가 저장장소에 코드를 커밋

- 코드 변경 사항은 운영 환경과 일치하는 환경에 통합

`테스트`

- JenKins나 Ansible과 같은 배포 자동화 툴에서 새로운 코드를 인식하고 일련의 테스트를 수행

- 테스트를 통과한 빌드는 운영 환경으로 릴리즈 가능

`배포`

- 소프트웨어를 운영 환경에 배포하여 사용자에게 제공

### 종류

`Make`

- 유닉스 계열 운영체제에서 주로 사용되는 프로그램 빌드 도구

- 파일 간 종속관계를 파악하여 기술파일(Makefile)에 적힌 내용을 컴파일러가 순차적으로 실행

`Ant`

- Java 기반의 빌드 도구로 다른 빌드 도구보다 오래됨

- 개발자가 원하는 형태로 개발을 할 수 있다는 유연성이 장점

- XML 기반의 빌드 스크립트로 개발

- 스크립트의 재사용이 어려움

- Remote Repository를 가져올 수 없음

`Maven`

- 프로젝트에 필요한 모든 Dependency를 리스트 형태로 Maven에게 알려 관리할 수 있도록 돕는 방식

- 필요한 라이브러리를 특정 파일(pom.xml)에 정의해 놓으면 해당 라이브러리와 관련된 라이브러리까지 네트워크를 통해 자동으로 다운

- 정해진 라이프사이클에 의하여 작업 수행, 전반적인 프로젝트 관리 기능 포함

`Jenkins`

- Java 기반의 오픈소스로 소프트웨어 개발 시 지속적 통합(Continuous integration) 서비스를 제공하는 툴

- 서블릿 컨테이너에서 실행되는 서버 기반 도구

- SVN, Git 등 대부분의 형상 관리 도구와 연동 가능

- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

`Gradle`

- Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구로 안드로이드 앱 개발 환경에서 사용

- 안드로이드 뿐만 아니라 플러그인을 설정하면 Java, C/C++, Python 등의 언어도 빌드가 가능

- Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용

- Gradle은 실행할 처리 명령들을 모아 테스크로 만든 후 테스크 단위 실행