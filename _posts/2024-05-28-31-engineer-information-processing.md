---
title: 31. 운영체제 기초 활용 3
date: 2024-05-28
categories: [정보처리기사]
tags: [정보처리기사]
layout: post
---

## Scheduling

### 개념

- 메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 순서를 정하는 것

- Ready Queue에 있는 프로세스들 중 누구에게 CPU를 할당해 줄 것인지 정하는 것

### 목적

`공평성` : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안됨  
`효율성` : 시스템 자원을 최대한 활용하여 스케줄링 해야 함  
`안정성` : 중요한 프로세스가 먼저 처리되도록 함  
`반응 시간 보장` : 적절한 시간 안에 프로세스의 요구에 반응해야 함  
`무한 연기 방지` : 특정 프로세스의 작업이 무한하게 연기되어서는 안됨  

### 성능척도

> 
> 
> 
> #### 프로세서 차원
> 
> 
>
> - CPU 사용률
> - 처리량 | Throughput
> 
> 
> 
> #### 프로세스 차원
> 
> 
> `응답시간 | Response Time`
>
> - 프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간
> 
> `대기시간 | Waiting Time`
>
> - 프로세스가 CPU를 할당받기 전 대기 상태일 때의 시간
> 
> `반환시간 | Turn-around Time`
>
> - 프로세스가 생성되어 종료된 후 자원을 모두 반환하는데 걸리는 시간
> 
> 

### 기법

`선점형 스케줄링 | Preemptive`

- 다른 프로세스가 실행 중이더라도 운영체제가 CPU를 강제로 뺏을 수 있는 방식

- CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능

- 잦은 문맥 교환으로 오버헤드가 많이 발생

- 종류 : Round Robin, SRT, 다단계 큐(MLQ | Multi-Level Queue), 다단계 피드백 큐(MFQ | Multi-Level Feedback Queue) 등

`비선점형 스케줄링 | Non-Preemptive`

- 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식

- 순서대로 처리되는 공정성 보장

- 다음에 처리해야 할 프로세스와 관계없이 응답시간을 예상할 수 있음

- 낮은 문맥 교환으로 오버헤드가 적음

- CPU 사용시간이 짧은 여러 프로세스가 오래 기다릴 수 있어, 처리율이 떨어질 수 있음

- 종류 : FCFS, SJF, HRN, 우선순위, 기한부 등

---

## 스케줄링 알고리즘

### 선점형 기법

`Round Robin`

- 시간단위(Time Quantum / Slice)를 정해서 프로세스를 순서대로 CPU를 할당하는 방식

- 컴퓨터 자원을 사용할 수 있는 기회를 프로그램 프로세스들에게 공정하게 부여하기 위한 방법

`SRT | Shortest Remaining Time`

- 비선점 스케줄링인 SJF 기법을 선점 형태로 변경한 기법

- CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식

`다단계 큐 | Multi-Level Queue`

- 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비 상태 큐를 사용하는 기법

- 특정 그룹의 준비상태 큐에 들어갈 경우 다른 준비상태 큐로 이동할 수 없음

- 하위 준비 상태 큐에 있는 프로세스를 실행하는 도중이라도 상위 준비 상태 큐에 프로세스가 들어오면 상위 프로세스에게 CPU를 할당

`다단계 피드백 큐 | Multi-Level Feedback Queue`

- 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 등록된 프로세스는 FCFS 순서로 CPU를 할당받아 실행되고, 할당된 시간이 끝나면 다음 단계의 준비큐로 이동

- 단계가 내려갈수록 시간 할당량이 증가하고, 가장 하위큐는 Round Robin 방식으로 운영

- 적응 기법(Adaptive Mechanism)의 개념을 적용

### 비 선점형 기법

`FCFS | First Come, First Service`

- 먼저 도착한 프로세스를 먼저 처리하는 스케줄링 알고리즘

- 공평성이 유지되지만, 중요한 작업이 중요치 않은 작업에 밀려서 늦게 처리되는 문제점 발생

- 실행시간이 긴 프로세스가 먼저 도착하게 되면, 효율성이 떨어지는 현상 발생

`SJF | Shortest Job First`

- 실행시간이 가장 짧은 프로세스에게 CPU를 할당하는 방식

- 짧은 작업들을 우선적으로 처리하다 보니, 평균 대기시간이 가장 적은 최적의 스케줄링 기아현상이 발생할 수 있음

`HRN | Highest Response Ratio Next`

- SJF 기법에서 실행시간이 긴 프로세스가 가질 수 있는 불리함을 보완한 스케줄링 방식

- 우선순위를 계산해서 프로세스들에게 순서를 부여하는 방식

- 우선순위 = (대기시간 + 실행시간) / 실행시간

- 실행시간이 짧은 프로세스에게 밀려서 오랫동안 기다린 프로세스가 더 높은 우선순위를 가지게 됨

`우선순위 | Priority`

- 프로세스마다 우선순위를 부여하여 높은 우선순위를 가진 프로세스에게 먼저 자원을 할당

- 우선순위가 낮을 경우 기아상태가 일어날 수 있음

`기한부 | Deadline`

- 프로세스에게 일정한 시간을 주어 그 시간 안에 완료하도록 하는 기법

- 주어진 시간 내에 완료되지 못할 경우, 해당 프로세스는 제거되거나 처음부터 다시 실행되어야 하므로 부담이 매우 큰 기법

---

## 병행 프로세스와 교착상태

### 병행 프로세스

- 두 개 이상의 프로세스들이 동시에 존재하며 실행 상태에 있는 것

`문제점`

- 동시에 2개 이상의 프로세스를 병행 처리하면 한정된 자원(CPU, 메모리, 디스크, I/O 장치 등)에 대한 사용 순서 등의 문제가 발생

`해결책`

- 임계구역

- 상호배제 기법

- 동기화 기법

### 임계 구역 | Critical Section

- 여러 개의 프로세스에 의하여 공유되는 데이터 및 자원에 대하여 한 순간에는 반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록 하고, 이러한 자원이 프로세스에 의하여 반납된 후 비로소 다른 프로세스에서 자원을 이용하거나 데이터를 접근할 수 있도록 지정된 영역

`특징`

- 특정 프로세스가 독점할 수 없음

- 프로세스가 임계구역에 대한 진입을 요청하면 일정 시간 내에 진입을 허락해야 함

### 상호 배제 | Mutual Exclusion

- 한 프로세스가 공유 메모리 혹은 공유 파일을 사용하고 있을 때 다른 프로세스들이 사용하지 못하도록 배제시키는 제어 기법

`상호 배제 기법`

- Dekker's Algorithm

- Peterson's Algorithm

- Dijkstra Algorithm

- Lamport's Bakery Algorithm

### 동기화 기법

- 스레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법

`Semaphore`

- 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법

- 다익스트라가 제안

- P와 V라는 2개의 연산에 의해서 동기화를 유지시키고, 상호 배제의 원리를 보장

- P는 임계구역에 들어가기 전에 수행되고, V는 임계 구역에서 나올 때 수행

- 종류 : 계수 세마포어, 이진 세마포어

`Monitor`

- 프로그래밍 언어 수준에서 동시성을 제어하여 타이밍 오류를 해결한 상호 배제 기법

- 모니터 내의 자원을 공유하려면 프로세스는 반드시 모니터의 진입부를 호출해야 함

- 모니터 외부의 프로세스는 모니터 내부의 데이터를 직접 액세스 할 수 없음

- Wait와 Signal 연산이 사용

### 교착 상태 | Dead Lock

- 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

`발생 조건`

> 
> 
> 
> #### 상호 배제 | Mutual Exclusion
> 
> 
>
> - 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
> 
> 
> 
> #### 점유와 대기 | Hold & Wait
> 
> 
>
> - 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 요구하며 대기
> 
> 
> 
> #### 비선점 | NonPreemption
> 
> 
>
> - 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
> 
> 
> 
> #### 환형 대기 | Circular Wait
> 
> 
>
> - 각 프로세스가 순차적으로 다음 프로세스가 요구하고 있는 자원을 가지고 있는 상태
> 
> 

`해결 방법`

> 
> 
> 
> #### 예방 기법 | Prevention
> 
> 
>
> - 교착상태가 발생되지 않도록 사전에 시스템을 제어하는 방법
> 
> 
> 
> #### 회피 기법 | Avoidance
> 
> 
>
> - 교착상태가 발생하려고 할 때, 교착상태 가능성을 피해가는 방법
> - 주로 은행원 알고리즘(Banker's Algorithm) 사용
> 
> 
> 
> #### 발견 기법 | Detection
> 
> 
>
> - 시스템에 교착 상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것
> 
> 
> 
> #### 회복 기법 | Recovery
> 
> 
>
> - 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것
> 
> 

---

## Disk Scheduling

### 개념

- 사용할 데이터가 디스크 상의 여러 곳에 저장되어 있을 경우, 데이터를 액세스하기 위해 디스크 헤드를 움직이는 경로를 결정하는 기법

- 효율적으로 데이터를 액세스 하는 방법

### 목표

- 하드 디스크 검색으로 낭비되는 시간을 최소화

- 특정한 프로세스의 입출력 요청의 우선순위를 정함

- 디스크 대역을 실행중인 각 프로세스에 할당

- 정해진 기한까지 요청을 처리

### 종류

`FCFS 스케줄링 | First Come First Served`

- 요청이 들어온 순서대로 처리

- 장점 : 알고리즘이 다른 기법보다 단순하며, 공평하게 요청을 처리

- 단점 : 비용이 많이 발생되어 비효율적

`SSTF | Shortest Seek Time First`

- 현재 헤드에서 가장 가까운 트랙의 요청을 먼저 처리

- 장점
  - Seek Time이 적음
  - 트랙을 찾는 시간을 최소화할 수 있음
  - 처리량(Throughput)을 극대화할 수 있음

- 단점
  - 안쪽 및 바깥쪽에 있는 요청들은 기아 현상이 발생할 수 있음

`SCAN`

- 헤드의 진행방향에 있는 요청을 처리하고, 다시 반대 방향으로 틀어 반대방향에 있는 요청들을 처리

- 엘리베이터가 동작하는 원리가 같아서 엘리베이터 기법이라고도 함

- 진행되는 과정에서 요청이 들어오면 해당 요청도 처리

- 장점 : SSTF의 바깥쪽 트랙의 기아 가능성을 제거할 수 있고, 응답시간의 편차를 줄일 수 있음

- 단점 : 양 쪽 끝 트랙은 가운데 위치한 트랙보다 대기 시간이 길어짐

`C-SCAN`

- 항상 한쪽 방향에서 반대방향으로 진행하며 트랙의 요청을 처리

- 바깥쪽에서 안쪽으로 진행하며 요청을 처리

- SCAN의 변형된 형태로 조금 더 시간을 균등하게 배분할 수 있음

- 진행되는 과정에서 요청이 들어오면 해당 요청은 처리하지 않음

- 장점 : 응답시간의 편차가 매우 적음, SCAN보다 시간 균등성이 좋음

- 단점 : 안쪽이나, 바깥쪽으로 처리할 요청이 없어도 헤드셋이 끝까지 이동하기 때문에 비효율적

`LOOK`

- SCAN 기법을 기초로 사용하며, 진행 방향의 마지막 요청을 처리한 후 반대 방향으로 처리하는 기법

`C-LOOK`

- C-SCAN 기법을 기초로 사용하며, 바깥쪽에서 안쪽 방향의 모든 요청을 처리한 후, 가장 바깥쪽으로 이동한 후 다시 안쪽 방향으로 서비스 하는 기업

`N-STEP SCAN`

- SCAN 기법을 기초로 두고 있으며, 시작하기 전 대기하고 있는 요청들을 우선적으로 처리하고, 처리하는 과정 중에 요청이 들어오는 것들은 이후에 모아서, 반대방향으로 진행할 때 서비스

`에션바흐 기법 | Eschenbach`

- 부하가 매우 큰 항공 예약 시스템을 위해 개발

- 탐색 시간과 회전 지연 시간을 최적화하기 위한 최초의 기법

---

## 환경 변수

### 개념

- 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임

- OS에서 프로세스들을 생성할 때 참조하는 '변수'

### UNIX / Linux 환경변수

- env, set, printenv 명령어들을 사용하여 환경 변수와 그에 따른 모든 값을 볼 수 있음

- export 명령을 이용하여 사용자 환경 변수를 전역 변수로 설정할 수 있음

> 
> 
> 
> #### 종류
> 
> 
> `$PATH` : 디렉터리의 경로  
> `$HOME` : 사용자의 홈 디렉터리  
> `$LANG` : 기본 지원되는 언어  
> `$USER` : 사용자의 이름  
> `$TERM` : 로그인 터미널 타입  
> `$PS1` : 1차 명령 프롬프트 변수  
> `$HISTFILE` : 히스토리 파일의 절대 경로  
> `$MAIL` : 도착한 메일이 저장되는 경로   
> `$TMOUT` : 로그인 후 일정시간 작업을 하지 않을 경우 로그아웃시키는 시간  
> `$UID` : 사용자의 UID  
> `$PWD` : 사용자의 현재 작업 디렉토리  
> `$DISPLAY` : X 윈도우에서 프로그램 실행 시 출력되는 창  
> `$OSTYPE` : 운영체제 타입
> 

### Windows 환경 변수

- 제어판 -> 시스템 및 보안 -> 시스템 -> 고급 시스템 설정 -> 환경변수

- 커맨드 창에서 set 명령으로 확인

> 
> 
> 
> #### 종류
> 
> 
> `%HOMEDRIVE%` : 로그인한 계정 정보가 들어있는 드라이브  
> `%HOMEPATH%` : 로그인한 계정의 폴더  
> `%SYSTEMDRIVE%` : 윈도우가 부팅된 드라이브  
> `%SYSTEMROOT%` : 부팅된 운영체제가 들어있는 폴더  
> `%PROGRAMFILES%` : 기본 프로그램 설치 폴더  
> `%TEMP%` : 임시 파일이 저장되는 폴더  
> `%COMSPEC%` : 기본 명령 프롬프트 프로그램  
> `%USERDOMAIN%` : 로그인한 시스템의 도메인명  
> `%USERNAME%` : 로그인한 계정 이름  
> `%USERPROFILE%` : 로그인한 유저의 프로필이 들어있는 폴더명  
> `%ALLUSERPROFILE%` : 모든 사용자 프로필이 저장된 폴더   
> `%APPDATA%` : 설치된 프로그램의 필요 데이터가 저장된 폴더  
> `%PATH%` : 실행 참조용 폴더 지정 목록
> 

---

## 로그 파일

### 개념

- 시스템의 모든 기록을 담고 있는 데이터

### 로그 데이터 정보

- 외부로부터의 침입 감지 및 추적

- 시스템 성능 관리

- 마케팅 전략으로 활용

- 시스템의 장애 원인 분석

- 시스템 취약점 분석

### 로그 데이터 중요성

- 시스템에서 발생하는 모든 문제에 대한 유일한 단서

- 시스템에서 발생한 오류 및 보안 결함 검색이 가능

- 잠재적인 시스템 문제를 예측하는 데 사용

- 장애발생 시 복구에 필요한 정보로 활용

- 침해사고 시 근거 자료로 활용

### 리눅스 로그 종류

`messages` : 시스템 로그 파일  
`secure` : 보안인증에 관한 메시지 로그파일  
`maillog` : 메일 로그 파일  
`xferlog` : ftp 로그 파일  
`dmesg` : 부팅 시의 시스템 로그  
`wtmp` : 시스템에 로그인 기록이 저장되는 파일(전체 로그인 기록)  
`utmp` : 시스템에 로그인 기록이 저장되는 파일(현재 로그인 사용자에 대한 기록)  
`lastlog` : 각 계정들의 가장 최근 로그인 기록  
`btmp` : 로그인 실패 정보 기록  

---

## 쉘 스크립트

### 개념

- 쉘에게 무슨 명령들을 실행할지 알려주는 스크립트 파일

- 명령어 창에 직접 입력했던 명령어들을 일종의 파일로 표현해서, 이 파일을 실행했을 때 해당 명령어들이 직접 입력된 듯한 효과를 주는 것

### 기본 문법

`주석`

- #으로 주석 처리

`입력 / 출력`

- 입력 : read

- 출력 : echo

- 변수명 = 값으로 선언

- 사용시 앞에 $를 붙임

```shell
read Name
echo "hello, $NAME!"

h = "hello"
w = "world"
echo "${h}, ${w}"
```

`예약변수`

- HOME : 사용자 홈 디렉토리

- PATH : 실행 파일의 경로

- LANG : 프로그램 실행 시 지원되는 언어

- UID : 사용자 ID

- SHELL : 사용자가 로그인 시 실행되는 쉘

- USER : 사용자의 계정 이름

- FUNCNAME : 현재 실행되고 있는 함수 이름

- TERM : 로그인 터미널

`IF 조건문`

- 기본작성법 : if [조건] then 작업내용 fi

```shell
a = 10
b = 5
if [ ${a} -eq ${b} ]; then
	echo "a와 b는 같다"
fi
```

`Switch 조건문`

- 기본작성법 : case 변수 in 조건 작업내용;; esac

```shell
a = 10
case "$a" in
	10) echo "10입니다"
    ;;
    5) echo "5입니다"
    ;;
esac
```

`반복문`

- while loop : 조건과 일치할 때 반복

- until loop : 조건과 일치할 때까지 반복

- for loop : 조건이나 값이 일치하는 경우 반복