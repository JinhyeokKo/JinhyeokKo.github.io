---
title: CPU 구성과 기능
date: 2025-10-03
categories:
  - CS
tags:
  - 컴퓨터구조
layout: post
updated: 2025-10-12
---

## CPU의 핵심 구성 요소

### 산술/논리 연산 장치(Arithmetic Logic Unit, ALU)
덧셈, 뺄셈 같은 **산술 연산**과 AND, OR, NOT 같은 **논리 연산**을 직접 수행하는 디지털 회로입니다. 제어 장치로부터 특정 연산을 수행하라는 신호를 받으면, 레지스터에 저장된 데이터를 가져와 계산을 수행하고 그 결과를 다시 레지스터에 저장합니다.

### 제어 장치(Control Unit, CU)
주기억 장치에서 가져온 명령어(Instruction)를 해석(Decode)하고, 그 해석 결과에 따라 각 장치(ALU, 레지스터, 메모리 등)에 적절한 제어 신호를 순서에 맞게 보내 작업을 지시합니다.

CPU의 모든 동작은 이 제어 장치의 신호에 따라 움직이며 CPU 내부와 다른 하드웨어 장치 간의 데이터 흐름을 관리합니다.

### 레지스터
CPU 내부에 존재하는, 메모리 계층 구조에서 가장 빠른 기억장치입니다. 연산에 필요한 데이터, 연산 결과, 명령어 주소 등을 임시로 보관합니다.

#### CPU 내부의 대표적인 레지스터
레지스터는 역할에 따라 크게 **특수 목적 레지스터**와 **범용 레지스터**로 나뉩니다.

**특수 목적 레지스터 (Special-Purpose Register)**  
특정 기능이 정해져 있는 레지스터입니다.

- **프로그램 카운터(Program Counter, PC)**
	- 다음에 실행할 명령어의 메모리 주소를 저장합니다. 명령어가 하나 실행되면 자동으로 다음 명령어 주소를 가리키도록 증가하거나, 분기(Jump) 명령어에 의해 특정 주소로 값이 변경됩니다.
- **명령어 레지스터(Instruction Register, IR)**
	- 현재 실행 중인 명령어 그 자체를 저장합니다. 제어 장치는 IR에 있는 제어 장치는 IR의 내용을 분석하여 필요한 제어 신호를 생성합니다.
- **메모리 주소 레지스터(Memory Address Register, MAR)**
	- CPU가 접근하려는 메모리의 주소를 저장하며 명령어를 인출할 때는 PC의 값을 받고, 메모리의 데이터를 읽거나 쓸 때는 IR에 있는 주소 값을 받습니다. 시스템의 주소 버스와 직접 연결됩니다.
- **메모리 버퍼 레지스터(Memory Buffer Register, MBR)**
	- 메모리에서 읽어온 데이터나 메모리에 쓸 데이터를 임시로 저장합니다. 데이터 버퍼 레지스터(DBR)라고도 하며, 시스템의 데이터 버스와 연결됩니다.
- **누산기(Accumulator, AC)**
	- ALU에서 수행된 연산의 결과를 일시적으로 저장하는 레지스터입니다.

**범용 레지스터 (General-Purpose Register, GPR)**  
이름 그대로 다양한 용도로 사용할 수 있는 레지스터입니다. 컴파일러나 어셈블리 프로그래머가 연산에 필요한 데이터나 주소 등을 자유롭게 임시 저장하는 공간으로 활용합니다. (x86 아키텍처의 `EAX`, `EBX`, ARM 아키텍처의 `R0`, `R1` 등)

## CPU의 명령어 처리 흐름(Instruction Cycle)
CPU는 전원이 켜진 순간부터 꺼질 때까지 **명령어 사이클**이라는 정해진 흐름을 끊임없이 반복합니다. 이 사이클은 크게 **인출(Fetch), 해석(Decode), 실행(Execute), 저장(Store)** 의 4단계로 나눌 수 있습니다.

### 1단계 : 인출(Fetch Cycle)
메모리에서 명령어를 가져오는 단계입니다.

1. **PC → MAR** : 제어 장치가 **PC**에 저장된 다음 명령어의 주소를 **MAR**로 보냅니다.
2. **Memory → MBR** : 제어버스를 통해 '메모리 읽기' 신호를 보내면, MAR에 지정된 메모리 주소의 명령어가 데이터 버스를 통해 **MBR**로 들어옵니다.
3. **MBR → IR** : MBR에 담긴 명령어를 **IR**로 옮깁니다.
4. **PC 증가** : 다음 명령어를 인출하기 위해 **PC의 값을 1 증가**시킵니다. (또는 명령어 길이에 맞게 증가)
	- 분기/점프 명령일 경우에는 단순히 +1이 아니라, 분기 대상 주소가 PC에 저장됩니다.

### 2단계 : 해독(Decode Cycle)
가져온 명령어를 분석하는 단계입니다.

1. 제어 장치(CU)는 **IR** 에 있는 명령어의 비트 패턴(연산 코드, 오퍼랜드)을 해석합니다.
2. 이 명령어가 어떤 종류의 작업인지(연산, 메모리 접근, I/O 파악), 작업에 필요한 데이터의 위치는 어디인지(메모리 주소, 레지스터 번호) 등을 파악하고, 이후 실행단계에 필요한 제어 신호를 준비합니다.
	- 피연산자 주소가 있으면 다시 MAR로 전달하여 데이터를 준비합니다.

### 3단계 : 실행(Execute Cycle)
명령어에 따라 실제 작업을 수행하는 단계입니다.

1. 제어 장치가 해석된 명령어에 따라 필요한 장치(ALU, 레지스터 등)에 제어 신호를 보냅니다.
2. **데이터 이동** : 메모리나 레지스터 간에 데이터를 옮겨야 한다면, MAR과 MBR을 사용해 데이터를 가져옵니다.
3. **연산 수행** : 데이터의 입출력 또는 메모리 접근 등의 작업이 이루어지며, 신술/논리 연산이 필요하면 **ALU**가 레지스터로부터 데이터를 받아 연산을 수행합니다.
	- 연산 결과는 보통 **누산기(AC)** 나 범용 레지스터에 저장됩니다.

### 4단계 : 저장(Store Cycle)
실행 결과를 최종적으로 저장하는 단계입니다.

1. 실행 단계에서 처리된 결과(누산기나 다른 레지스터에 저장된 값)를 메모리나 다른 레지스터에 저장합니다.
2. 이 과정이 끝나면, CPU는 다시 1단계인 인출 사이클로 돌아가 PC가 가리키는 다음 명령어를 가져와 이 모든 과정을 반복합니다.

